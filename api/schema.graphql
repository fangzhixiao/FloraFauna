scalar GraphQLDate

enum SightingType {
    ANIMAL
    PLANT
}

type Location {
    lat: Float!
    lng: Float!
}

type Comment {
    commenter: String!
    content:String!
    created: GraphQLDate!
}

input CommentInput {
    commenter: String!
    content:String!
    created: GraphQLDate!
}

type Post {
    _id: ID!
    id: String!
    title: String!
    sightingType: SightingType!
    authorId: Int!
    created: GraphQLDate!
    spotted: GraphQLDate!
    location: Location!
    imageUrls:[String]
    description: String
    comments: [Comment]
}

type User {
    _id: ID!
    id: Int!
    signedIn: Boolean!
    givenName: String
    email: String
}

input LocationInput {
    lat: Float!
    lng: Float!
}

input UserInput {
    givenName: String
    email: String
}

"Toned down Posts, used as inputs, without server generated values."
input PostInput {
    title: String!
    sightingType: SightingType!
    authorId: Int!
    created: GraphQLDate!
    spotted: GraphQLDate!
    location: LocationInput!
    images:[String]
    description: String
}

"""Inputs for postUpdate: all are optional. Whichever is specified will be set to the given value,
undefined fields will remain unmmodified."""

input PostUpdateInput {
    title: String
    sightingType: SightingType
    spotted: GraphQLDate
    location: LocationInput
    description: String
    comments: [CommentInput]
}

##### Top level declarations
# Query and Mutation define the entry point of every GraphQL query
type Query {
    about: String!
    postList(
        sightingType: SightingType
        search: String
        authorId: Int
        spotted: GraphQLDate
        minHour: GraphQLDate
        maxHour: GraphQLDate
    ): [Post!]!
    post(id: String!): Post!
    user: User!
}

type Mutation {
    setAboutMessage(message: String!): String
    userFind(user: UserInput): User!
    postAdd(post: PostInput!): Post!
    postUpdate(id: String!, changes: PostUpdateInput!): Post!
    postDelete(id: String!): Boolean!
    postRestore(id: String!): Boolean!
}
